### JAVA基础

#### 基础

1. ==和equals的区别？
2. hashCode()与equals()？
3. 8种基本数据类型，对应的包装类型？
4. **自动拆、装箱？从编译角度回答**
5. **Integer和String的常量池？**
6. 重载和重写的区别
7. **深拷贝、浅拷贝？**
8. 在静态方法内调用非静态成员为什么非法？
9. 接口和抽象类的区别？
10. StringBuilder、StringBuffer和String的区别？
11. 对final的认识？
12. Comparable和Comparator区别？
13. 如何是集合变为不可变集合？Collctions.Unmodifiable...()
14. 对异常的认识？
    - Throwable(Error，Exception(IOException，RuntimeException))
15. 字符流和字节流的区别？
16. BIO、NIO和AIO？

#### 集合

##### Collection和Map

1. List、Set、Map三者区别？
2. List、Set、Map的各自实现类？
   - List：ArrayList、LinkedList、Vector
   - Set：HashSet、TreeSet、LinkedHashSet
   - Map：HashMap、LInkedHashMap、TreeMap
3. Iterator的作用？
4. 哪些集合线程不安全，如何解决？
5. ArrayList和Vector的区别？
6. ArrayList和LinkedList的区别？
7. ArrayList的扩容机制？
8. HashMap和HashTable的区别？

##### HashMap

1. HashMap的数据结构？
2. 当两个对象的hashcode相同会发生什么？
3. HashMap的table容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？
4. HashMap中put方法的过程
5. 数组扩容的过程？
6. 拉链法导致的链表过深问题为什么不用二叉查找树替代，而选择红黑树？
7. JDK8对HashMap做了哪些改变？
8. HashMap、TreeMap、LinkedHashMap的使用场景？
9. HashMap和HashTable的区别？
10. Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，他与HashTable在线程同步上有什么不同？
11. HashMap和ConcurrentHashMap的区别？
12. 为什么ConcurrentHashMap比HashTable效率更高？
13. 针对ConcurrentHashMap锁机制具体分析（JDK1.7 vs JDK1.8）？
14. ConcurrentHashMap在JDK1.8中，为什么使用内置锁Synchronized来代替重入锁ReentrantLock？
15. ConcurrentHashMap简单介绍？
16. ConcurrentHashMap的并发度是什么？

#### 多线程



#### 缓存

1. 为什么使用缓存？高性能、高并发

2. Redis和Memcached的区别？

3. 为啥Redis单线程模型也能效率这么高？

   - 纯内存操作
   - 核心是基于非阻塞IO多路复用机制
   - C语言实现
   - 单线程避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题

4. Redis的雪崩、穿透和击穿，如何应对？

   - 雪崩：①事前：Redis高可用，主从+哨兵防止全盘崩溃②事中：本地ehcache缓存+hystrix限流降级，避免MySQL崩掉③事后：Redis持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据

   - 穿透：①接口层参数校验②查到空值也放到缓存，给出较短的有效期
   - 击穿：①若缓存的数据基本不会发生更新，可以尝试将该热点数据设置为永不过期②若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少，可采用基于Redis、Zookeeper的分布式互斥锁来更新缓存③若缓存数据更新频繁或缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动重新构建缓存或者延后缓存的过期时间

#### 消息队列

1. 为什么使用消息队列？异步、解耦、削峰
2. 消息队列有什么缺点？系统可用性降低，系统复杂性提高，一致性问题
3. 如何保证消息不被重复消费？
   - 数据库唯一主键来限制，先查id，存在就修改，不存在就插入
   - 写Redis天然幂等，直接set
   - 将全局唯一Id放入redis，消费的时候查一下redis，存在就是消费过，否则就是未消费
4. 如何保证消息的可靠性传输？
   - 生产者造成消息丢失
   - MQ导致消息丢失
   - 消费者导致消息丢失
5. **如何保证消息的顺序性？**
6. 如何解决消息队列的延时以及过期失效问题？
   - 假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是**大量的数据会直接搞丢**
   - 这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是**批量重导**，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了
   - 假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次
7. 消息队列满了以后该怎么处理？
   - 没有办法，晚上重新导数据吧
8. 有几百万消息持续积压几小时，说说怎么解决？出现这个问题肯定是consumer出问题了
   - 修复consumer的问题，确保其恢复消费速度，然后将现有consumer都停掉
   - 新建一个topic，partition是原来10倍，临时建立好原先10倍的queue数量
   - 然后写一个临时分发数据的consumer程序，这个程序部署上去消费积压数据，**消费之后不做耗时的处理**，直接均匀轮询写入临时建立好的10倍数量的queue
   - 接着征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据。这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常10倍的速度来消费数据
   - 等快速消费完积压数据之后，**得恢复原先部署的架构**，**重新**用原先的 consumer 机器来消费消息



[石杉架构笔记](https://doocs.github.io/advanced-java/#/./docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages)

##### 算法相关

题目一：

```java
1、输入小明的身高和他们班其他小朋友的个数
比如 100 5
2、输入这5个小朋友的身高 中间用空格隔开（身高的范围是0-200）
98 99 100 101 102
输出
按照跟小明的身高差去排序，身高差相同，个子小的排在前面
100 99 101 98 102```
```

题目二：

```java

输入一个字符串 和一个标志
例子：  aA1bB2cC3 1
假如这个标志是 1  就把字符串中小写字母反转输出  cA1bB2aC3
假如这个标志是 2  就把字符串中大写写字母反转输出  aC1bB2cA3
假如这个标志是 3  就把字符串中数字的位置反转输出  aA3bB2aC1
```

题目三：

```java
题目三：
先输入一个行数
比如说是2    再输入两个字符串(用逗号隔开)
4,5,4
5,4,5
然后输入操作的步骤数目
比如说是2，每一次输入标志了上面二维数组里面的两个数字
0,0,0,2   00代表了第1行第一列的4   02和第一行第三列的4  
(如果这两个数字能用三根短线连起来，并且相等，那么就把这两个位置上的数字变成0)
1,0,0,1  同上(10是5  01也是5)
如果输入的多组操作，都能正常完成数字的消除，就返回0k
如果有一组操作存在错误，就返回这个操作的下标。
分析错误的原因：操作里面指明的位置在二维数组里面没有,下标越界，两个下标的值不相等，或者就是不能用三个短线把这两个数连起来
```

##### JVM

1. JVM的垃圾回收机制

2. 后面是类加载子系统（这两个问题我还ok）

内存分配策略影响垃圾回收机制，用GCRoot进行可达性分析找到需要回收的对象。然后在不同的分代区域运用不同的垃圾回收算法。为什么要对堆空间进行分代划分，三条分代假说理论支撑。

类加载，沙箱安全策略，加载链接初始化都干了什么，链接的三个小步骤分别又干了什么。

##### 持久层框架

Mybatis和JPA 项目配置连接

（我没回答好，MyBatis就不该写在简历上，没看过源码，但是不写有怕简历被筛掉，机会都没有）

数据库连接源还好，连接资源复用，几个参数还是记得的，只是底层的一些东西我就不知道了，得好好补一补这些了。

##### Redis

这个也是常问的，这次主要问了 缓存、分布式锁怎么实现的、基本数据类型。

但是Redis能问的实在是太多了，缓存雪崩、击穿、穿透 三连，持久化，集群，分布式锁，双写一致性，布隆过滤器，这些是我知道的，底层很多东西我都不知道，跳跃表，哈希表实现那些。

##### 场景模拟

4、之后是一个场景模拟题：假设现在并发很大，怎么去保证数据库安全

我回答：

首先在服务层面设置限流或者熔断机制，配置一些限流规则，优先保证核心功能可用。

之后对读写情况redis该怎么做，读那就缓存基本能搞定，写的话就有缓存大批量更新的问题，redis怎么做才撑得住。

之后是数据库层面怎么做。

（反正我觉得我回答的不是很好）

##### 算法题

算是比较简单吧。一个数组找最大的K个。口述那就更简单了。

堆排序。

（我是这样的，如果是学校里面学的数据结构，算法啊这些我可能还会一点点，但是比较高级的就是纯粹懵掉的那种。因为当时比较叛逆，没想着在课上好好学这些基础的东西，只好好上那些找工作要用的课，当时也不知道这些课其实很重要，所以现在只能恶补）

##### 实际问题解决

6、然后是内存泄露。

奈何我答个稀烂，我以为是OOM。等我反应过来的时候就......

然后追着我问netty的线程模型，我只我勉强还记得两个线程组实现异步处理，一个负责监听连接事件，一个负责处理其他事件。之后问我怎么实现监听的，后面她说有几个方法怎么怎么做，我就好像想起来一点了......(真太久了，记不得了，也是答个稀烂)



7、然后问 hashcode 我也没有答好，我只说在对象头里面存放的hashcode，是懒生成的，用来判定对象相等，但是大部分情况是比较地址值。

之后我看了一下，Object类的hashcode是用native方法生成的，是用地址值，而散列集合的hashcode是被重写过的，以所有key的hashcode之和作为自己的hashcode。我猜她想问的是这个。

8、然后问我HashMap，put和resize的过程肯定是必问的，这个我还是ok的。后面问ConcurrentHashMap，也还行。