#### 常见问题

1. **堆空间的基本结构**？
   
   - 年轻代：eden区，survivor区(from和to)
   - 年老代
   
2. **堆内存常见的分配策略**？

   - 对象优先在eden区分配
   - 大对象直接进入年老代(连续空间的数组或列表)
   - 长期存活对象进入年老代

3. **如何判断对象已经废弃**？

   - 引用计数法：为对象添加计数器，有引用该对象的地方时，计数器+1
     - 优点：效率高，简单
     - 缺点：存在循环引用问题
   - 可达性分析算法：通过一系列GcRoots的对象为起点向下搜索，走过的路径为引用链，没在引用链上为废弃对象

4. **如何判定废弃常量和废弃类**

   - 废弃常量：jdk1.8之后常量在堆空间的常量池中，当没有任何引用变量引用该常量时，该常量就会被判定为废弃常量
   - 废弃类：需要满足三个条件
     - 堆空间没有该类对应的实例
     - 加载该类的ClassLoader已经被回收
     - 该类的`java.lang.Class`对象没有被引用，即无法通过反射等方法创建实例

5. **垃圾回收算法**

   - 标记清除算法：先标记再清除，有效率问题且会产生大量不连续的内存碎片
   - 标记整理算法：先标记，将标记数据移到内存一端，清除其余部分，有效率问题但不会产生内存碎片
   - 复制算法：将内存一份为二，使用一半内存，当垃圾回收时将存活对象放入另一半，然后清理自己的内存。好处是效率高且没有内存碎片，但会牺牲一半内存。在jvm中年轻代使用复制算法，但年轻代对象都是朝生夕死，所以内存分配时eden占用80%，而survivor占用%20来使用
   - 分代收集算法(常用)
     - 年轻代使用复制算法
     - 年老代使用标记清除或标记整理算法

6. **垃圾收集器**

   - Hotspot虚拟机的垃圾收集器

     <img src="img/hotspot虚拟机的垃圾收集器.png" style="zoom:60%;" >

   - Serial收集器：串行收集器，使用单线程进行垃圾收集，当GC线程收集时，工作线程必须暂停(**stop the world**)直至收集结束，**年轻代使用复制算法，年老代使用标记整理算法**

     - 优点：**简单且高效**（与其他收集器的单线程相比），适合用在client端

     - 缺点：**stop the world**，用户体验差

       <img src="img/serial收集器.png" style="zoom:80%;" >

   - ParNew收集器：Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为都和Serial收集器一毛一样，**年轻代采用复制算法，年老代使用标记整理算法**，只有**Serial收集器和ParNew收集器**能与**CMS收集器**配合工作

   - Parallel Scavenge收集器：年轻代收集器，也是并行的多线程收集器，**年轻代使用复制算法，年老代使用标记整理算法**，唯一不同：**Parallel Scavenge收集器的关注点是高效利用CPU，即吞吐量(运行用户代码时间/(运行用户代码时间+垃圾收集时间))，而CMS的收集器关注的是用户线程的停顿时间(提高用户体验)**

   - Serial Old收集器：Serial收集器的年老代版本，主要有两大用途：一种用途是在Jdk1.5及以前版本与Parallel Scavenge收集器配合使用，另一种是作为CMS收集器的后备方案

   - Parallel Old收集器：**Parallel Scavenge收集器的年老代版本。**使用标记整理算法，注重吞吐量和CPU的高效利用

   - CMS收集器：一种以获得**最短回收停顿时间**为目标的收集器，注重**用户体验**，使用**标记清除算法**，**初始标记和重新标记**都会产生**Stop The World**
   
     - 执行步骤
       - **初始标记**：记录下与GC Roots直接相连的对象，速度很快
       - **并发标记**：同时开启GC和用户线程，用一个闭包结构记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程会不断更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法会跟踪记录发生引用更新的地方
       - **重新标记**：重新标记是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，速度上会略微慢于初始标记
       - **并发清除**：清除标记的对象
     - 缺陷：
       - **对CPU资源敏感**
       - **无法清理浮动垃圾**
       - **使用标记清除算法，会产生大量内存碎片**
   
   - G1收集器：是一款面向服务器的收集器，主要针对配备多核大内存的机器，以极高概率满足GC停顿时间的同时，还具备高吞吐量性能的特征
   
     - 特点
       - **并行与并发**：G1可以充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行
       - **分代收集**：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念
       - **空间整合**：与CMS的标记--清理算法不同，G1从整体来看是基于标记整理算法实现的收集器；从局部上来看是基于复制算法实现的
       - **可预测的停顿**：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M 毫秒的时间片段内。
     - 执行步骤
       - **初始标记**
       - **并发标记**
       - **最终标记**
       - **筛选回收**
     - **G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）
     
     <img src="img/G1收集器.png" style="zoom:100%;" >