#### 并发常见问题

1. 为什么要用到并发，并发优缺点？
   - 优点：
     - 提高业务的处理能力
   - 缺点：
     - 频繁上下文切换问题
       - 解决方案：cas，分段锁(concurrenthashmap)
     - 线程安全问题
       - 临界资源的使用
       - 死锁问题
   
2. 线程状态和基本操作？
   
   - 状态：NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED
   
3. java内存模型和happens-before规则？
   
   - JMM内存模型
   
4. 死锁的四个条件与避免死锁？
   - 互斥条件：该资源同一时刻只能被一个线程访问
   - 请求与保持条件：一个线程阻塞时，不释放占有的资源
   - 不剥夺条件：线程占用资源时，该资源不能被其他线程获取
   - 循环等待条件：若干线程形成循环等待关系
   - 解决：破坏四个条件之一
   
5. sleep方法和wait方法的区别？
   - **sleep没有释放锁，wait释放了锁**
   - 都可以暂停线程的执行
   - wait一般用来做线程交互/通信，而sleep通常用于线程暂停执行
   - wait后需要使用notify或notifyAll来唤醒，而sleep可以自动苏醒
   
6. 对synchronized的理解？

   - [ ] TODO

7. synchronized的用法？
   - 修饰实例方法：锁对象是当前实例
   - 修饰静态方法：所对象是当前类
   - 修饰代码块：指定加锁对象

8. synchronized底层原理？

   - [ ] 从字节码的monitorenter和monitorexit来答

9. JDK1.6以后synchronized都做了哪些优化？

   - [ ] TODO

10. 谈谈synchronized和ReentrantLock的区别？

    |     特性     | synchronize | ReentrantLock |
    | :----------: | :---------: | :-----------: |
    |    可重入    |      √      |       ×       |
    |    公平锁    |      ×      |       √       |
    |   非公平锁   |      √      |       √       |
    |   超时等待   |      ×      |       √       |
    |   尝试加锁   |      ×      |       √       |
    |   Java特性   |      √      |       ×       |
    |   响应中断   |      ×      |       √       |
    |  自动释放锁  |      √      |       ×       |
    | 对异常的处理 | 自动释放锁  |  手动释放锁   |

11. volatile关键的作用？

    - 防止指令重排
    - 解决变量的内存可见性
    - 完整的volatile可见性保证
    - [并发编程网volatile关键字](http://ifeve.com/java-volatile关键字/)

12. 谈谈对ThreadLocal的认识？

    - 存放每个线程的私有数据，其实也是一种map，key为线程对象，value为存储的值(通过get和set方法设置和获取内容)
    - 用在哪，怎么用，一些细节，最佳实践？
    - [并发编程网ThreadLocal](http://ifeve.com/手撕面试题threadlocal！！！/)
    
13. ThreadLocal原理是怎样的，为什么可以做到线程隔离？

    - TODO
    - 线程隔离：每个Thread维护一个ThreadLocalMap，而ThreadLocal仅仅作为每个线程ThreadLocalMap的key，所以线程隔离(**Thread-->ThreadLocalMap(ThreadLocal，value)**)

14. ThreadLocal的内存泄露问题

15. 为什么使用线程池？

    - **降低资源消耗**：通过重复利用已创建的线程降低线程创建和销毁造成的消耗
    - **提高响应速度**：任务到达后，任务可以不需要等待线程的创建并直接执行
    - **提高线程的可管理性**：线程是稀缺资源，使用线程池可以进行统一分配，调优和监控

16. Runnable和Callable接口的异同？

    - 两者都是函数式接口
    - Callable调用的是call方法，有返回值，会抛出异常，而Runnable接口调用的是run方法，没有返回值，不会抛异常。所以不需要抛异常和返回值，使用Runnable

    ```java
    @FunctionalInterface
    public interface Callable<V> {
        V call() throws Exception;
    }
    @FunctionalInterface
    public interface Runnable {
        public abstract void run();
    }
    ```

17. 