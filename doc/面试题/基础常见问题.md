#### 常见问题

1. String，StringBuilder和StringBuffer的区别？

   - 实现字符数组
   - 是否final修饰
   - 线程是否安全
   - 使用场景

2. 为什么静态方法不能调用非静态变量？

   - 所属不同，静态方法属于类，非静态变量数据对象
   - 静态方法随类加载而加载，此时非静态变量对静态方法还不可见

3. 为什么重写equals需要重写hashcode？

4. ==和equals的区别？

   - ==：基本数据类型比较的是值，引用数据类型比较的是内存地址
   - equals：
     - 没有Object的equals方法，本质使用==，比较内存地址
     - 覆盖Object的equals方法，大多情况比较对象内容是否相等，其余情况要视覆盖类的equals逻辑而定

5. java是值传递还是引用传递？

   - java中只有值传递

   ```java
   public static void main(String[] args) {
       String str = "abc";
       StringBuilder sb1 = new StringBuilder("abc");
       StringBuilder sb2 = new StringBuilder("abc");
       method(str, sb1, sb2);
       System.out.println("main.str: " + str);
       System.out.println("main.sb1: " + sb1);
       System.out.println("main.sb2: " + sb2);
   }
   // str，sb1，sb2都把内存地址传了过来
   public static void method(String str, StringBuilder sb1, StringBuilder sb2) {
       // 此处应确定str是不可变对象，改变method的str不会对main的str改变
       str = "methodabc";	// 映射情况main.str-->内存地址<--method.str
       sb1 = new StringBuilder("methodabc"); // 映射情况main.sb1-->内存地址<--method.sb1
       sb2.append("methodabc");			  // 映射情况main.sb2-->内存地址<--method.sb2
       System.out.println("method.str: " + str);
       System.out.println("method.sb1: " + sb1);
       System.out.println("method.sb2: " + sb2);
   }
   ```

6. 对final的认识？

   - 修饰变量：变量初始化后不可改变
   - 修饰方法：方法不可被覆盖
   - 修饰类：类不可被继承

7. 对java中异常的认识？

   - Throwable：Error，Exception
   - 我们常用Exception，Exception属于编译异常，必须通过trycatch或throws处理，否则不通过编译
   - 其次就是RuntimeException，运行时异常，不需要处理也能通过，我们使用自定义异常基本都是继承的RuntimeException

8. 对于序列化对象中的字段比较敏感不适合序列化如何解决？

   - transient关键词修饰变量且只能修饰变量
   - 静态变量不能被序列化

9. 深拷贝和浅拷贝？

   - 深拷贝：基本数据类型是值传递，引用类型则是创建一个新的对象，把原对象的内容都赋值过来
   - 浅拷贝：基本数据类型是值传递，引用类型是将原对象所有属性引用传递给新对象，本质上指向同一对象
   
10. 关于四种引用：

    - 强引用
    - 软引用
    - 弱引用
    - 虚引用